import json
import logging
import re
from typing import Dict, Any, List, Optional

# Import constants and classes from other modules
from MassAudit_Pro.config import MAX_CONTEXT_RETRIES, MAX_CALLS_PER_PROJECT, PROJECT_API_CALL_COUNTS
from MassAudit_Pro.core.api_caller import APICaller
from MassAudit_Pro.core.context_resolver import ContextResolver

class VulnerabilityAnalyzer:
    """
    ç®¡ç†Agentic Context Loopï¼ŒåŒ…æ‹¬åˆå§‹è¯·æ±‚ã€AIå“åº”è§£æã€ä¸Šä¸‹æ–‡æ£€ç´¢å’Œé€’å½’å¢å¼ºPromptï¼Œ
    å¹¶å®ç°ä¸Šä¸‹æ–‡é€’å½’ç†”æ–­ã€‚
    """
    def __init__(self, api_caller: APICaller, context_resolver: ContextResolver, project_api_call_counts: Dict[str, int]):
        """
        åˆå§‹åŒ–VulnerabilityAnalyzerã€‚
        :param api_caller: APICallerå®ä¾‹ï¼Œç”¨äºä¸DeepSeek APIäº¤äº’ã€‚
        :param context_resolver: ContextResolverå®ä¾‹ï¼Œç”¨äºæŸ¥æ‰¾ä»£ç ä¸Šä¸‹æ–‡ã€‚
        :param project_api_call_counts: å­˜å‚¨æ¯ä¸ªé¡¹ç›®APIè°ƒç”¨æ¬¡æ•°çš„å­—å…¸ã€‚
        """
        self.api_caller = api_caller
        self.context_resolver = context_resolver
        self.project_api_call_counts = project_api_call_counts
        logging.info("VulnerabilityAnalyzer initialized with APICaller, ContextResolver, and project API call tracking.")

    def _build_initial_prompt(self, initial_code_snippet: str, project_name: str = "", file_path: str = "", line_number: int = 0) -> List[Dict[str, str]]:
        """
        æ„å»ºåˆå§‹çš„AIè¯·æ±‚æ¶ˆæ¯ï¼ŒåŒ…å«ä»£ç ç‰‡æ®µã€JSONæ ¼å¼è¦æ±‚ä»¥åŠPoCç”ŸæˆæŒ‡ä»¤ã€‚
        """
        system_prompt = (
            "ä½ æ˜¯ä¸€ä¸ªç»éªŒä¸°å¯Œçš„é«˜çº§å®‰å…¨æ¶æ„å¸ˆï¼Œä¸“æ³¨äºä»£ç å®¡è®¡å’Œæ¼æ´åˆ†æã€‚\n"
            "ä½ çš„ä»»åŠ¡æ˜¯åˆ†ææä¾›çš„ä»£ç ç‰‡æ®µï¼Œåˆ¤æ–­æ˜¯å¦å­˜åœ¨å®‰å…¨æ¼æ´ã€‚\n"
            "è¯·ä¸¥æ ¼ä»¥JSONæ ¼å¼å“åº”ï¼Œä¸è¦åŒ…å«Markdownæ ‡è®°ã€‚\n"
            "\n"
            "ã€ä»»åŠ¡è¦æ±‚ã€‘\n"
            "1. åˆ¤å®šæ¼æ´: `status` ä¸º `final` æˆ– `need_context`ã€‚\n"
            "2. å®šçº§: `verdict` ä¸º `High`, `Medium`, `Low`, `Safe`ã€‚\n"
            "3. PoCåˆ¤æ–­ (å…³é”®): å¦‚æœ verdict ä¸º High/Mediumï¼Œè¯·åˆ¤æ–­æ˜¯å¦å¯ä»¥é€šè¿‡ Go å•å…ƒæµ‹è¯• (`go test`) è¿›è¡ŒéªŒè¯ã€‚\n"
            "   - é€»è¾‘æ¼æ´ã€Panicã€è¶Šç•Œã€æ­£åˆ™ç»•è¿‡ã€XSS/SQLå­—ç¬¦ä¸²æ„é€ é€šå¸¸å¯æµ‹ã€‚\n"
            "   - ä¾èµ–å¤æ‚å¤–éƒ¨ç¯å¢ƒï¼ˆå¦‚ç‰¹å®šæ•°æ®åº“çŠ¶æ€ã€ä¸­é—´ä»¶ï¼‰çš„é€šå¸¸ä¸å¯æµ‹ã€‚\n"
            "4. ç”Ÿæˆè„šæœ¬: å¦‚æœ `is_testable` ä¸º trueï¼Œè¯·ç¼–å†™ä¸€ä¸ªå®Œæ•´çš„ Go æµ‹è¯•æ–‡ä»¶å†…å®¹ (`_test.go`)ã€‚\n"
            "   - åŒ…å (`package`) å¿…é¡»ä¸åŸæ–‡ä»¶ä¸€è‡´ã€‚\n"
            "   - åŒ…å« `func TestExploit_Auto(t *testing.T)`ã€‚\n"
            "   - ä½¿ç”¨ `defer` å’Œ `recover` æ•è· panicã€‚\n"
            "   - ä»£ç å¿…é¡»è‡ªåŒ…å«ï¼ŒMock å¿…è¦å¯¹è±¡ã€‚\n"
            "\n"
            "ã€å“åº”æ ¼å¼ (JSON)ã€‘\n"
            "å¦‚æœéœ€è¦ä¸Šä¸‹æ–‡: `{\"status\": \"need_context\", \"target_function\": \"...\"}`\n"
            "å¦‚æœå¾—å‡ºç»“è®º: \n"
            "{\n"
            "  \"status\": \"final\",\n"
            "  \"verdict\": \"[high|medium|low|safe]\",\n"
            "  \"reason\": \"...\",\n"
            "  \"is_testable\": true/false,\n"
            "  \"poc_code\": \"å®Œæ•´çš„Goä»£ç å­—ç¬¦ä¸²(å¦‚æœ‰)...\",\n"
            "  \"target_package\": \"æ¨æµ‹çš„åŒ…å\"\n"
            "}"
        )
        user_prompt = (
            f"ã€é¡¹ç›®ä¸Šä¸‹æ–‡ã€‘\n"
            f"é¡¹ç›®: {project_name}\n"
            f"æ–‡ä»¶: {file_path} (è¡Œå·: {line_number})\n"
            f"ã€ä»£ç ç‰‡æ®µã€‘\n"
            f"```\n{initial_code_snippet}\n```\n"
            "è¯·åˆ†æï¼Œå¦‚æœæ— æ³•åˆ¤æ–­ï¼Œè¯·æ˜ç¡®æŒ‡å‡ºéœ€è¦å“ªä¸ªå‡½æ•°æˆ–å˜é‡çš„å®šä¹‰ä½œä¸ºä¸Šä¸‹æ–‡ã€‚"
        )
        return [
            {"role": "system", "content": system_prompt},
            {"role": "user", "content": user_prompt}
        ]

    def _build_context_prompt(self, messages: List[Dict[str, str]], context_info: List[Dict[str, Any]]) -> List[Dict[str, str]]:
        """
        å°†æ‰¾åˆ°çš„ä¸Šä¸‹æ–‡ä»£ç å—è¿½åŠ åˆ°AIçš„åç»­è¯·æ±‚æ¶ˆæ¯ä¸­ã€‚
        """
        context_string = "\n--- é¢å¤–ä¸Šä¸‹æ–‡ä¿¡æ¯ ---\n"
        for ctx in context_info:
            context_string += (
                f"åœ¨æ–‡ä»¶ `{ctx['file_path']}` ä¸­æ‰¾åˆ°ä»¥ä¸‹ `{ctx['language']}` ä»£ç å—ï¼Œå†…å®¹ä¸º `{ctx['target_name']}` çš„å®šä¹‰ï¼š\n"
                f"```\n{ctx['code_block']}\n```\n"
            )
        context_string += "\nè¯·ç»“åˆä»¥ä¸Šä¸Šä¸‹æ–‡ï¼Œç»§ç»­åˆ†æå¹¶ç»™å‡ºæ¼æ´åˆ¤æ–­ï¼ˆå¦‚ç¡®è®¤ä¸ºé«˜å±ä¸”å¯æµ‹ï¼Œè¯·è®°å¾—ç”Ÿæˆ PoC ä»£ç ï¼‰ã€‚"

        # å°†ä¸Šä¸‹æ–‡è¿½åŠ åˆ°æœ€æ–°çš„ç”¨æˆ·æ¶ˆæ¯ä¸­
        updated_messages = list(messages) # å¤åˆ¶åˆ—è¡¨ä»¥é¿å…ä¿®æ”¹åŸå§‹å¼•ç”¨
        if updated_messages and updated_messages[-1]['role'] == 'user':
            updated_messages[-1]['content'] += context_string
        else: # å¦‚æœæœ€åä¸€ä¸ªä¸æ˜¯ç”¨æˆ·æ¶ˆæ¯ï¼Œæˆ–è€…åˆ—è¡¨ä¸ºç©ºï¼Œåˆ™ä½œä¸ºæ–°ç”¨æˆ·æ¶ˆæ¯æ·»åŠ 
            updated_messages.append({"role": "user", "content": context_string})

        return updated_messages

    def _safe_parse_json(self, raw_response: str) -> Dict[str, Any]:
        """
        [æ–°å¢] å¥å£®çš„ JSON è§£æå™¨ï¼Œèƒ½å¤„ç† Markdown åŒ…è£¹ã€æˆªæ–­ç­‰é—®é¢˜ã€‚
        """
        try:
            return json.loads(raw_response)
        except json.JSONDecodeError:
            pass
        
        # 1. å°è¯•æå– ```json ... ``` å†…å®¹
        try:
            if "```json" in raw_response:
                content = raw_response.split("```json")[1].split("```")[0].strip()
                return json.loads(content)
            elif "```" in raw_response: # å¯èƒ½æ˜¯ ``` ... ```
                content = raw_response.split("```")[1].split("```")[0].strip()
                return json.loads(content)
        except:
            pass

        # 2. å°è¯•æå– { ... }
        try:
            start = raw_response.find("{")
            end = raw_response.rfind("}")
            if start != -1 and end != -1:
                json_str = raw_response[start:end+1]
                return json.loads(json_str)
        except:
            pass

        # 3. å°è¯•ä¿®å¤æˆªæ–­çš„ JSON (ç®€å•çš„å­—ç¬¦ä¸²è¡¥å…¨)
        # å¦‚æœæ˜¯ Unterminated stringï¼Œé€šå¸¸æ˜¯å› ä¸º poc_code å¤ªé•¿äº†
        # è¿™æ˜¯ä¸€ä¸ªéå¸¸æ¿€è¿›çš„ä¿®å¤ï¼Œä»…åœ¨ä¸‡ä¸å¾—å·²æ—¶ä½¿ç”¨
        try:
            # å‡è®¾ poc_code æ˜¯æœ€åä¸€ä¸ªå­—æ®µï¼Œä¸”è¢«æˆªæ–­äº†
            # æˆ‘ä»¬å°è¯•é—­åˆå¼•å·å’ŒèŠ±æ‹¬å·
            if '"poc_code": "' in raw_response and raw_response.strip().endswith('"'):
                 # çœ‹èµ·æ¥åƒæ˜¯æ­£å¸¸çš„ç»“å°¾
                 pass
            else:
                 # æš´åŠ›è¡¥å…¨
                 repaired = raw_response + '"}' 
                 return json.loads(repaired)
        except:
            pass

        raise json.JSONDecodeError("Failed to parse JSON even after cleanup", raw_response, 0)

    def analyze_vulnerability(
        self,
        project_name: str,
        initial_code_snippet: str,
        project_path: str, # For ContextResolver
        file_path: str, # For reporting
        line_number: int # For reporting
    ) -> Dict[str, Any]:
        """
        å®ç°æ ¸å¿ƒçš„â€œAnalyze - Feedback - Refineâ€å¾ªç¯ã€‚
        """
        # [ä¿®æ”¹] ä¼ é€’é¡¹ç›®ä¿¡æ¯ç»™ _build_initial_prompt ä»¥ä¾¿ç”Ÿæˆæ›´å¥½çš„ PoC
        current_messages = self._build_initial_prompt(initial_code_snippet, project_name, file_path, line_number)
        
        analysis_log = []
        final_result = {"status": "skipped", "verdict": "unknown", "reason": "Analysis not completed."}

        logging.info(f"[INFO] ğŸ•µï¸ Project {project_name}: Starting analysis for snippet at {file_path}:{line_number}")

        # Initialize project call count if not present
        if project_name not in self.project_api_call_counts:
            self.project_api_call_counts[project_name] = 0

        for retry_count in range(MAX_CONTEXT_RETRIES + 1): # +1 to include the initial request
            current_round_log = {"round": retry_count, "request": current_messages[-1]['content']}

            # --- Project-level API call limit check ---
            if self.project_api_call_counts[project_name] >= MAX_CALLS_PER_PROJECT:
                logging.warning(f"[WARN] âŒ Project {project_name}: Hit API limit ({self.project_api_call_counts[project_name]}/{MAX_CALLS_PER_PROJECT}), stopping analysis for this vulnerability.")
                final_result = {"status": "skipped", "verdict": "SKIPPED_QUOTA_LIMIT", "reason": "Project API call limit exceeded."}
                analysis_log.append(current_round_log) # Log the attempt before hitting limit
                break

            if APICaller._circuit_breaker_tripped: # Check global circuit breaker
                logging.critical(f"[ERROR] Global API circuit breaker tripped. Terminating analysis for {project_name}.")
                final_result = {"status": "aborted", "verdict": "unknown", "reason": "Global API circuit breaker tripped."}
                analysis_log.append(current_round_log) # Log the attempt before global trip
                break

            try:
                logging.info(f"[INFO] ğŸ•µï¸ Project {project_name}: Sending request to AI (Round {retry_count + 1}/{MAX_CONTEXT_RETRIES + 1}) - API Calls for Project: {self.project_api_call_counts[project_name]}/{MAX_CALLS_PER_PROJECT}")
                raw_response = self.api_caller.call_llm(messages=current_messages)
                self.project_api_call_counts[project_name] += 1 # Increment call count after successful API call
                
                current_round_log["raw_response"] = raw_response
                
                # [ä¿®æ”¹] ä½¿ç”¨ _safe_parse_json æ›¿ä»£ç›´æ¥ json.loads
                ai_response = self._safe_parse_json(raw_response)
                
                current_round_log["parsed_response"] = ai_response

                status = ai_response.get("status")

                if status == "final":
                    logging.info(f"[INFO] ğŸ•µï¸ Project {project_name}: AI reached final conclusion: {ai_response.get('verdict')}")
                    final_result = ai_response
                    break
                elif status == "need_context":
                    target_function = ai_response.get("target_function")
                    if not target_function:
                        logging.warning(f"[WARN] Project {project_name}: AI requested context but 'target_function' was not provided. Forcing conclusion.")
                        final_result = {"status": "final", "verdict": "medium", "reason": "AI requested context but did not specify target_function. Concluding with existing info."}
                        break

                    logging.info(f"[INFO] ğŸ•µï¸ Project {project_name}: AI requested context for '{target_function}'")
                    current_round_log["requested_context"] = target_function

                    context_info = self.context_resolver.resolve_context(project_path, target_function)
                    current_round_log["resolved_context"] = context_info

                    if context_info:
                        logging.info(f"[INFO] ğŸ•µï¸ Project {project_name}: Found {len(context_info)} context blocks for '{target_function}'. Appending to prompt.")
                        current_messages.append({"role": "assistant", "content": raw_response})
                        current_messages = self._build_context_prompt(current_messages, context_info)
                        current_messages.append({"role": "user", "content": f"ç»“åˆä¸Šè¿°ä¸Šä¸‹æ–‡ï¼Œè¯·ç»§ç»­åˆ†æï¼š"})
                    else:
                        logging.warning(f"[WARN] Project {project_name}: Could not find context for '{target_function}'. Forcing conclusion.")
                        final_result = {"status": "final", "verdict": "medium", "reason": f"AI requested context for '{target_function}' but it could not be found. Concluding with existing info."}
                        break
                else:
                    logging.error(f"[ERROR] Project {project_name}: AI returned unknown status '{status}'. Forcing conclusion.")
                    final_result = {"status": "final", "verdict": "medium", "reason": f"AI returned unknown status '{status}'. Concluding with existing info."}
                    break

            except json.JSONDecodeError as e:
                logging.error(f"[ERROR] Project {project_name}: AI response was not valid JSON: {raw_response[:200]}... Error: {e}. Forcing conclusion.")
                # è¿™é‡Œå¯ä»¥åšä¸€ä¸ªæ›´ä¼˜é›…çš„é™çº§ï¼Œä¾‹å¦‚è®¤ä¸ºåˆ†æå¤±è´¥ä½†ç»§ç»­æµç¨‹
                final_result = {"status": "final", "verdict": "medium", "reason": f"AI returned malformed JSON (truncated or invalid). Error: {e}. Concluding with existing info."}
                break
            except RuntimeError as e: # Catch circuit breaker trip from APICaller
                logging.error(f"[ERROR] Project {project_name}: API call failed due to {e}. Forcing conclusion.")
                final_result = {"status": "aborted", "verdict": "unknown", "reason": f"API call failed due to {e}."}
                break
            except Exception as e:
                logging.error(f"[ERROR] Project {project_name}: An unexpected error occurred during AI interaction: {e}. Forcing conclusion.")
                final_result = {"status": "final", "verdict": "medium", "reason": f"An unexpected error occurred during AI interaction: {e}. Concluding with existing info."}
                break
            finally:
                analysis_log.append(current_round_log)

        if retry_count == MAX_CONTEXT_RETRIES and final_result["status"] not in ["final", "aborted", "skipped"]:
            logging.warning(f"[WARN] Project {project_name}: Context recursion limit reached ({MAX_CONTEXT_RETRIES} retries). Forcing AI to provide conclusion.")
            last_chance_messages = list(current_messages)
            if last_chance_messages and last_chance_messages[-1]['role'] == 'user':
                last_chance_messages[-1]['content'] += "\næ­¤ä¸ºæœ€åä¸€æ¬¡è¯·æ±‚ï¼Œè¯·åŠ¡å¿…æ ¹æ®å·²æœ‰ä¿¡æ¯ç»™å‡ºæœ€ç»ˆæ¼æ´åˆ¤æ–­ï¼ˆåŒ…å« is_testable å’Œ poc_code å­—æ®µï¼‰ã€‚"
            else:
                last_chance_messages.append({"role": "user", "content": "æ­¤ä¸ºæœ€åä¸€æ¬¡è¯·æ±‚ï¼Œè¯·åŠ¡å¿…æ ¹æ®å·²æœ‰ä¿¡æ¯ç»™å‡ºæœ€ç»ˆæ¼æ´åˆ¤æ–­ï¼ˆåŒ…å« is_testable å’Œ poc_code å­—æ®µï¼‰ã€‚"})

            try:
                raw_response = self.api_caller.call_llm(messages=last_chance_messages)
                self.project_api_call_counts[project_name] += 1 
                # [ä¿®æ”¹] ä½¿ç”¨ _safe_parse_json
                ai_response = self._safe_parse_json(raw_response)
                final_result = ai_response 
                logging.info(f"[INFO] Project {project_name}: AI provided final conclusion after context limit: {ai_response.get('verdict')}")
            except Exception as e:
                logging.error(f"[ERROR] Project {project_name}: Error during final attempt: {e}.")
                final_result = {"status": "final", "verdict": "medium", "reason": "Error during final attempt. Concluding with existing info."}

        final_result["analysis_log"] = analysis_log
        final_result["file_path"] = file_path
        final_result["line_number"] = line_number

        if not final_result.get("verdict"): 
            final_result["verdict"] = "unknown"

        return final_result

    def fix_poc_code(self, original_code: str, error_message: str) -> str:
        """
        [æ–°å¢] è‡ªæ„ˆæ¨¡å—ï¼šæ ¹æ®ç¼–è¯‘å™¨æŠ¥é”™ä¿®å¤ PoC ä»£ç ã€‚
        """
        system_prompt = "ä½ æ˜¯ä¸€å Go è¯­è¨€ä¿®å¤ä¸“å®¶ã€‚è¯·æ ¹æ®æŠ¥é”™ä¿¡æ¯ä¿®æ­£ä»£ç ã€‚è¯·åŠ¡å¿…ä»¥ JSON æ ¼å¼è¿”å›ç»“æœã€‚"
        
        p1 = f"æˆ‘ç¼–å†™äº†ä¸€ä¸ªç”¨äºéªŒè¯æ¼æ´çš„ Go å•å…ƒæµ‹è¯•ä»£ç ï¼Œä½†æ˜¯æŠ¥é”™äº†ã€‚\nè¯·æ ¹æ®æŠ¥é”™ä¿¡æ¯ä¿®æ­£ä»£ç ã€‚\n\nã€åŸå§‹ä»£ç ã€‘\n```go\n{original_code}\n```\n\n"
        p2 = f"ã€æŠ¥é”™ä¿¡æ¯ã€‘\n{error_message}\n\n"
        p3 = """ã€ä¿®å¤ç­–ç•¥ã€‘
        1. **Import é”™è¯¯**: ç§»é™¤æœªä½¿ç”¨çš„åŒ… (`imported and not used`)ï¼Œæˆ–æ·»åŠ ç¼ºå¤±çš„åŒ…ã€‚
        2. **ç»“æ„ä½“ç¼ºå¤±**: å¦‚æœæŠ¥é”™ `undefined: Response` ç­‰ï¼Œè¯·åœ¨æµ‹è¯•æ–‡ä»¶ä¸­å®šä¹‰ Mock ç»“æ„ä½“æˆ– Interfaceã€‚
        3. **å˜é‡é”™è¯¯**: åˆ é™¤å£°æ˜ä½†æœªä½¿ç”¨çš„å˜é‡ã€‚
        4. **è¯­æ³•é”™è¯¯**: ä¿®æ­£åŸºæœ¬çš„ Go è¯­æ³•é”™è¯¯ã€‚

        ã€è¾“å‡ºæ ¼å¼ã€‘
        è¯·åŠ¡å¿…è¿”å›ä¸€ä¸ªæ ‡å‡†çš„ JSON å¯¹è±¡ï¼Œæ ¼å¼å¦‚ä¸‹ï¼š
        {
         "fixed_code": "è¿™é‡Œå¡«ä¿®å¤åçš„å®Œæ•´ Go ä»£ç ï¼ˆä¸éœ€è¦ Markdown æ ‡è®°ï¼‰"
        }
        """
        user_prompt = p1 + p2 + p3

        messages = [
            {"role": "system", "content": system_prompt},
            {"role": "user", "content": user_prompt}
        ]

        try:
            logging.info(f"[Auto-Fix] ğŸ”§ Asking AI to fix code based on compiler errors...")
            raw_response = self.api_caller.call_llm(messages=messages)
            
            # [ä¿®æ”¹] ä½¿ç”¨ _safe_parse_json
            try:
                data = self._safe_parse_json(raw_response)
                clean_code = data.get("fixed_code", "")
                clean_code = clean_code.replace("```go", "").replace("```", "").strip()
                return clean_code
            except Exception:
                # æœ€åçš„å…œåº•
                return raw_response.replace("```go", "").replace("```", "").strip()

        except Exception as e:
            logging.error(f"[Auto-Fix] Failed to fix code: {e}")
            return original_code